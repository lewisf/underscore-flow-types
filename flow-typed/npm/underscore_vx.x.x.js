// flow-typed signature: 1cd95b8bf1dbc285635d7d136dcf68e0
// flow-typed version: <<STUB>>/underscore_v1.8.3/flow_v0.53.1

/**
 * This is an autogenerated libdef stub for:
 *
 *   'underscore'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the.
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

declare module 'underscore' {
  /* Utility types */
  declare type FnIteratee<T, Return> = (t: T, index?: number, array?: T[]) => Return;
  declare type FnPredicate<T> = FnIteratee<T, boolean>
  declare type UnaryFn<A, R> = (a: A) => R;

  declare type WrappedObject<O: {}> = {
    chain(): ChainedObject<O>,

    // Collection functions
    each: <A: $Values<O>>(iteratee: FnIteratee<A, void>, context?: mixed) => O,
		map: <A: $Values<O>, R>(iteratee: FnIteratee<A, R>, context?: mixed) => R[],
		reduce: <R>(
			iteratee: (acc: R, item: $Values<O>) => R,
			acc?: R,
      context?: mixed
    ) => R,
		reduceRight: <R>(
			iteratee: (acc: R, item: $Values<O>) => R,
			acc?: R,
      context?: mixed
    ) => R,
    find: <A: $Values<O>>(predicate: FnPredicate<A>, context?: mixed) => ?A,
    filter: <A: $Values<O>>(predicate: FnPredicate<A>, context?: mixed) => A[],
		where: <A: $Values<O>>(properties: Object) => A[],
		findWhere: <A: $Values<O>>(properties: Object) => ?A,
		reject: <A: $Values<O>>(predicate: FnPredicate<A>, context?: mixed) => A[],
		every: <A: $Values<O>>(predicate?: FnPredicate<A>, context?: mixed) => boolean,
		some: <A: $Values<O>>(predicate?: FnPredicate<A>, context?: mixed) => boolean,
		contains: <A: $Values<O>>(value: A, fromIndex?: number) => boolean,
		invoke: (methodName: string, ...args: any[]) => any,
		pluck: (propertyName: string) => any[],
		max: <A: $Values<O>>(iteratee?: FnIteratee<A, *>, context?: mixed) => number | typeof Infinity,
		min: <A: $Values<O>>(iteratee?: FnIteratee<A, *>, context?: mixed) => number | typeof Infinity,
		sortBy: <A: $Values<O>>(iteratee: FnIteratee<A, *>, context?: mixed) => A[],
		groupBy: <R, A: $Values<O>>(iteratee: FnIteratee<A, R>, context?: mixed) => { [key: R]: A[] },
		groupBy: <R, A: $Values<O>>(iteratee: R, context?: mixed) => { [key: R]: A[] },
		indexBy: <R, A: $Values<O>>(iteratee: FnIteratee<A, R>, context?: mixed) => { [key: R]: A[] },
		indexBy: <R, A: $Values<O>>(iteratee: R, context?: mixed) => { [key: R]: A[] },
		countBy: <R, A: $Values<O>>(iteratee: FnIteratee<A, R>, context?: mixed) => { [key: R]: number },
		countBy: <R, A: $Values<O>>(iteratee: R, context?: mixed) => { [key: R]: number },
    shuffle: <A: $Values<O>>() => Array<A>,
    // Unfortunately, for `sample`, we cannot determine whether or not the return
    // type here is a single element or an array.
    sample: <A: $Values<O>>(num?: number) => A | A[],
    toArray: <A: $Values<O>>() => Array<A>,
    size: <A: $Values<O>>() => number,
    partition: <A: $Values<O>>(predicate: FnPredicate<A>) => [A[], A[]],

    // Object-only functions
		// TODO: Get this working with ElementType?
		keys: () => WrappedList<string>,
		allKeys: () => string[],
    // TODO: Try Flow values support?
		values: () => $Values<O>[],
		mapObject: <R>(iteratee: FnIteratee<O, R>, context?: mixed) => {[keys: $Values<O>]: R},
    // TODO: More specific types possible?
    pairs: () => Array<any[]>,
    // TODO: More specific types possible?
    invert: () => Object,
    // TODO: create
    functions: () => string[],
    findKey: (predicate: FnPredicate<O>, context?: mixed) => ?$Keys<O>,
    // TODO: extend
    // TODO: extendOwn
    pick: (...keys: string[]) => Object,
    omit: (...keys: string[]) => Object,
    // TODO: Add more arguments into defaults
    // TODO: Add more arguments into defaults
    defaults: <D: {}>(defaults: D) => {...D, ...O},
    clone: () => O,
    // TODO: More precise function type
    tap: (interceptor: Function) => O,
    has: (key: string) => boolean,
    // TODO: Figure out if `property` is applicable here.
    propertyOf: () => ((key: string) => any),
    // TODO: matcher
    isEqual: () => boolean,
    isMatch: () => boolean,
    isEmpty: () => boolean,
    isElement: () => boolean,
    isArray: () => boolean,
    isObject: () => boolean,
    isArguments: () => boolean,
    isFunction: () => boolean,
    isString: () => boolean,
    isNumber: () => boolean,
    isFinite: () => boolean,
    isBoolean: () => boolean,
    isDate: () => boolean,
    isRegExp: () => boolean,
    isError: () => boolean,
    isNaN: () => boolean,
    isNull: () => boolean,
    isUndefined: () => boolean
  };

  declare type ChainedObject<O: {}> = {
    // Collection functions
    each: <A: $Values<O>>(iteratee: FnIteratee<A, void>, context?: mixed) => ChainedObject<O>,
		map: <A: $Values<O>, R>(iteratee: FnIteratee<A, R>, context?: mixed) => ChainedList<R>,
		reduce: <R, A: $Values<O>>(
			iteratee: (acc: R, item: A) => R,
			memo?: R,
      context?: mixed
    ) => ChainedValue<R>,
		reduceRight: <R, A: $Values<O>>(
			iteratee: (acc: R, item: A) => R,
			memo?: ChainedValue<R>,
      context?: mixed
    ) => R,
    find: <A: $Values<O>>(predicate: FnPredicate<A>, context?: mixed) => ChainedValue<?A>,
    filter: <A: $Values<O>>(predicate: FnPredicate<A>, context?: mixed) => ChainedList<A>,
		where: <A: $Values<O>>(properties: Object) => ChainedList<A>,
		findWhere: <A: $Values<O>>(properties: Object) => ChainedList<?A>,
		reject: <A: $Values<O>>(predicate: FnPredicate<A>, context?: mixed) => ChainedList<A>,
		every: <A: $Values<O>>(predicate?: FnPredicate<A>, context?: mixed) => ChainedValue<boolean>,
		some: <A: $Values<O>>(predicate?: FnPredicate<A>, context?: mixed) => ChainedValue<boolean>,
		contains: <A: $Values<O>>(value: A, fromIndex?: number) => ChainedValue<boolean>,
    // Does this work?
		invoke: (methodName: string, ...args: any[]) => ChainedValue<any>,
    // Does this work?
		pluck: (propertyName: string) => ChainedValue<any>,
		max: <A: $Values<O>>(iteratee?: FnIteratee<A, *>, context?: mixed) => ChainedValue<number | typeof Infinity>,
		min: <A: $Values<O>>(iteratee?: FnIteratee<A, *>, context?: mixed) => ChainedValue<number | typeof Infinity>,
		sortBy: <A: $Values<O>>(iteratee: FnIteratee<A, *>, context?: mixed) => ChainedList<A>,
		groupBy: <R, A: $Values<O>>(iteratee: FnIteratee<A, R>, context?: mixed) => ChainedObject<{ [key: R]: A[] }>,
		groupBy: <R, A: $Values<O>>(iteratee: R, context?: mixed) => ChainedObject<{ [key: R]: A[] }>,
		indexBy: <R, A: $Values<O>>(iteratee: FnIteratee<A, R>, context?: mixed) => ChainedObject<{ [key: R]: A[] }>,
		indexBy: <R, A: $Values<O>>(iteratee: R, context?: mixed) => ChainedObject<{ [key: R]: A[] }>,
		countBy: <R, A: $Values<O>>(iteratee: FnIteratee<A, R>, context?: mixed) => ChainedObject<{ [key: R]: number }>,
		countBy: <R, A: $Values<O>>(iteratee: R, context?: mixed) => ChainedObject<{ [key: R]: number }>,
    shuffle: <A: $Values<O>>() => ChainedList<A>,
    // Unfortunately, for `sample`, we cannot determine whether or not the return
    // type here is a single element or an array.
    sample: <A: $Values<O>>(num?: number) => ChainedValue<A> | ChainedList<A>,
    toArray: <A: $Values<O>>() => ChainedList<A>,
    size: <A: $Values<O>>() => ChainedValue<number>,
    // TODO: partition

    // Object-only functions
    value: () => O,
		keys: () => ChainedList<string>,
		allKeys: () => ChainedList<string>,
    // TODO: Try Flow values support?
		values: () => ChainedList<$Values<O>>,
		mapObject: <R>(iteratee: FnIteratee<O, R>, context?: mixed) => ChainedObject<{[keys: $Keys<O>]: R}>,
    // TODO: More specific types possible?
    pairs: () => ChainedList<any[]>,
    // TODO: More specific types possible?
    invert: () => ChainedObject<any>,
    // TODO: create
    functions: () => ChainedList<string>,
    findKey: (predicate: FnPredicate<O>, context?: mixed) => ChainedValue<?$Keys<O>>,
    // TODO: extend
    // TODO: extendOwn
    pick: (...keys: string[]) => ChainedObject<any>,
    omit: (...keys: string[]) => ChainedObject<any>,
    // TODO: Add more arguments into defaults
    defaults: <D: {}>(defaults: D) => {...D, ...O},
    clone: () => O,
    // TODO: More precise function type
    tap: (interceptor: Function) => O,
    has: (key: string) => boolean,
    // TODO: Figure out if `property` is applicable here.
    propertyOf: () => ((key: string) => any),
    // TODO: matcher
    isEqual: () => boolean,
    isMatch: () => boolean,
    isEmpty: () => boolean,
    isElement: () => boolean,
    isArray: () => boolean,
    isObject: () => boolean,
    isArguments: () => boolean,
    isFunction: () => boolean,
    isString: () => boolean,
    isNumber: () => boolean,
    isFinite: () => boolean,
    isBoolean: () => boolean,
    isDate: () => boolean,
    isRegExp: () => boolean,
    isError: () => boolean,
    isNaN: () => boolean,
    isNull: () => boolean,
    isUndefined: () => boolean
	}

	/**
   * I - Item's in array
   * A - Array type
   */
  declare type WrappedList<A> = {
		chain(): ChainedList<A>,

    // Collection functions
		each: (iteratee: FnIteratee<A, void>, context?: mixed) => A[],
		map: <R>(iteratee: FnIteratee<A, R>, context?: mixed) => R[],
		reduce: <R>(
			iteratee: (acc: R, item: A) => R,
			memo?: R,
      context?: mixed
    ) => R,
		reduceRight: <R>(
			iteratee: (acc: R, item: A) => R,
			memo?: R,
      context?: mixed
    ) => R,
    find: (predicate: FnPredicate<A>, context?: mixed) => ?A,
    filter: (predicate: FnPredicate<A>, context?: mixed) => A[],
		where: (properties: Object) => A[],
		findWhere: (properties: Object) => ?A,
		reject: (predicate: FnPredicate<A>, context?: mixed) => A[],
		every: (predicate?: FnPredicate<A>, context?: mixed) => boolean,
		some: (predicate?: FnPredicate<A>, context?: mixed) => boolean,
		contains: (value: A, fromIndex?: number) => boolean,
		invoke: (methodName: string, ...args: any[]) => any,
		pluck: (propertyName: string) => any[],
		max: (iteratee?: FnIteratee<A, *>, context?: mixed) => number | typeof Infinity,
		min: (iteratee?: FnIteratee<A, *>, context?: mixed) => number | typeof Infinity,
		sortBy: (iteratee: FnIteratee<A, *>, context?: mixed) => A[],
		groupBy: <R>(iteratee: FnIteratee<A, R>, context?: mixed) => { [key: R]: A[] },
		groupBy: <R>(iteratee: R, context?: mixed) => { [key: R]: A[] },
		indexBy: <R>(iteratee: FnIteratee<A, R>, context?: mixed) => { [key: R]: A[] },
		indexBy: <R>(iteratee: R, context?: mixed) => { [key: R]: A[] },
		countBy: <R>(iteratee: FnIteratee<A, R>, context?: mixed) => { [key: R]: number },
		countBy: <R>(iteratee: R, context?: mixed) => { [key: R]: number },
    shuffle: () => Array<A>,
    // Unfortunately, for `sample`, we cannot determine whether or not the return
    // type here is a single element or an array.
    sample: (num?: number) => A | A[],
    toArray: () => Array<A>,
    size: () => number,
    partition: (predicate: FnPredicate<A>) => [A[], A[]]
	};

  declare type ChainedList<A> = {
		value(): A,
    // Collection functions
		each: (iteratee: FnIteratee<A, void>, context?: mixed) => ChainedList<A>,
		map: <R>(iteratee: FnIteratee<A, R>, context?: mixed) => ChainedList<R>,
		reduce: <R>(
			iteratee: (acc: R, item: A) => R,
			memo?: R,
      context?: mixed
    ) => ChainedValue<R>,
    reduceRight: <R>(
      iteratee: (acc: R, item: A) => R,
      memo?: R,
      context?: mixed
    ) => ChainedValue<R>,
    find: (predicate: FnPredicate<A>, context?: mixed) => ChainedValue<?A>,
    filter: (predicate: FnPredicate<A>, context?: mixed) => ChainedList<A>,
		where: (properties: Object) => ChainedList<A>,
		findWhere: (properties: Object) => ChainedValue<?A>,
		reject: (predicate: FnPredicate<A>, context?: mixed) => ChainedList<A>,
		every: (predicate?: FnPredicate<A>, context?: mixed) => ChainedValue<boolean>,
		some: (predicate?: FnPredicate<A>, context?: mixed) => ChainedValue<boolean>,
		contains: (value: A, fromIndex?: number) => ChainedValue<boolean>,
		invoke: (methodName: string, ...args: any[]) => ChainedValue<any>,
		pluck: (propertyName: string) => ChainedList<any>,
		max: (iteratee?: FnIteratee<A, *>, context?: mixed) => ChainedValue<number | typeof Infinity>,
		min: (iteratee?: FnIteratee<A, *>, context?: mixed) => ChainedValue<number | typeof Infinity>,
		sortBy: (iteratee: FnIteratee<A, *>, context?: mixed) => ChainedList<A>,
		groupBy: <R>(iteratee: FnIteratee<A, R>, context?: mixed) => ChainedObject<{ [key: R]: A[] }>,
		groupBy: <R>(iteratee: R, context?: mixed) => ChainedObject<{ [key: R]: A[] }>,
		indexBy: <R>(iteratee: FnIteratee<A, R>, context?: mixed) => ChainedObject<{ [key: R]: A[] }>,
		indexBy: <R>(iteratee: R, context?: mixed) => ChainedObject<{ [key: R]: A[] }>,
		countBy: <R>(iteratee: FnIteratee<A, R>, context?: mixed) => ChainedObject<{ [key: R]: number }>,
		countBy: <R>(iteratee: R, context?: mixed) => ChainedObject<{ [key: R]: number }>,
    shuffle: () => ChainedList<A>,
    // Unfortunately, for `sample`, we cannot determine whether or not the return
    // type here is a single element or an array.
    sample: (num?: number) => ChainedValue<A> | ChainedList<A>,
    toArray: () => ChainedList<A>,
    size: () => ChainedValue<number>,
    partition: (predicate: FnPredicate<A>) => ChainedList<[A[], A[]]>
	}

  declare type ChainedValue<A> = {
		value(): A,
  };

  declare export function each<O: {}>(iterator: O, iteratee: FnIteratee<$Values<O>, void>, context?: mixed): O;
  declare export function each<I>(iterator: I[], iteratee: FnIteratee<I, void>, context?: mixed): I[];

  declare export function map<O: {}, R>(iterator: O, iteratee: FnIteratee<$Values<O>, R>, context?: mixed): R[];
  declare export function map<I, R>(iterator: I[], iteratee: FnIteratee<I, R>, context?: mixed): R[];
 
  declare export function reduce<O: {}, R>(iterator: O, iteratee: (acc: R, item: $Values<O>) => R, memo: R, context?: mixed): R;
  declare export function reduce<I, R>(iterator: I[], iteratee: (acc: R, item: I) => R, memo: R, context?: mixed): R;

  declare export function find<O: {}>(list: O, predicate: FnPredicate<$Values<O>>, context?: mixed): ?$Values<O>;
  declare export function find<I>(list: I[], predicate: FnPredicate<I>, context?: mixed): ?I;

  declare type Underscore = {
    property: (prop: ?string) => (() => any);

    // Array Collection Functions
    each: typeof each,
		map: typeof map,
		reduce: typeof reduce,
		reduceRight: typeof reduce,
    find: typeof find,
    filter: <I>(list: I[], predicate: FnPredicate<I>, context?: mixed) => I[],
		where: <I>(list: I[], properties: Object) => I[],
		findWhere: <I>(list: I[], properties: Object) => ?I,
		reject: <I>(list: I[], predicate: FnPredicate<I>, context?: mixed) => I[],
		every: <I>(list: I[], predicate?: FnPredicate<I>, context?: mixed) => boolean,
		some: <I>(list: I[], predicate?: FnPredicate<I>, context?: mixed) => boolean,
		contains: <I>(list: I[], value: I, fromIndex?: number) => boolean,
		invoke: <I>(list: I[], methodName: string, ...args: any[]) => any,
		pluck: <I>(list: I[], propertyName: string) => any[],
		max: <I>(list: I[], iteratee?: FnIteratee<I, *>, context?: mixed) => number | typeof Infinity,
		min: <I>(list: I[], iteratee?: FnIteratee<I, *>, context?: mixed) => number | typeof Infinity,
		sortBy: <I>(list: I[], iteratee: FnIteratee<I, *>, context?: mixed) => I[],
		groupBy: <I, R>(list: I[], iteratee: FnIteratee<I, R>, context?: mixed) => { [key: R]: I[] },
		groupBy: <I, R>(list: I[], iteratee: R, context?: mixed) => { [key: R]: I[] },
		indexBy: <I, R>(list: I[], iteratee: FnIteratee<I, R>, context?: mixed) => { [key: R]: I[] },
		indexBy: <I, R>(list: I[], iteratee: R, context?: mixed) => { [key: R]: I[] },
		countBy: <I, R>(list: I[], iteratee: FnIteratee<I, R>, context?: mixed) => { [key: R]: number },
		countBy: <I, R>(list: I[], iteratee: R, context?: mixed) => { [key: R]: number },
    shuffle: <I>(list: I[]) => I[],
    // Unfortunately, for `sample`, we cannot determine whether or not the return
    // type here is a single element or an array.
    sample: <I>(list: I[], num?: number) => I | I[],
    toArray: <I>(list: I[]) => I[],
    size: <I>(list: I[]) => number,
    partition: <I>(list: I[], predicate: FnPredicate<I>) => [I[], I[]]

  }

  declare function UObjectWrapper<O: {}>(arg: O): WrappedObject<O>;
  declare function UListWrapper<A>(arg: Array<A>): WrappedList<A>;
 
  declare export default Underscore & typeof UObjectWrapper & typeof UListWrapper;
}
